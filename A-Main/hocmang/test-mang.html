<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M√¥ Ph·ªèng M·∫°ng To√†n Di·ªán - DDoS & VLAN Effects</title>
    <script src="https://anhtu1.id.vn/A-Main/js/check-referrer.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap');

        :root {
            --bg-dark: #1e1e2f;
            --bg-light: #27293d;
            --primary-blue: #0d6efd;
            --secondary-yellow: #ffc107;
            --text-light: #e0e0e0;
            --border-color: #44475a;
            --red-error: #e53935;
            --green-success: #43a047;
            --purple-action: #6f42c1;
            --cable-color: #78909c;
            --export-color: #20c997;
            --import-color: #17a2b8;
            --ddos-color: #b71c1c;
            
            /* VLAN Colors */
            --vlan-color-1: #e91e63;
            --vlan-color-2: #9c27b0;
            --vlan-color-3: #3f51b5;
            --vlan-color-4: #03a9f4;
            --vlan-color-5: #009688;
            --vlan-color-6: #8bc34a;
            --vlan-color-7: #ff9800;
            --vlan-color-8: #795548;
        }

        @keyframes blink-error {
            0% { box-shadow: 0 0 10px var(--red-error); }
            50% { box-shadow: none; }
            100% { box-shadow: 0 0 10px var(--red-error); }
        }
        @keyframes highlight-success {
            0% { box-shadow: 0 0 12px var(--green-success); }
            100% { box-shadow: none; }
        }
        @keyframes data-flow { to { stroke-dashoffset: 0; } }

        @keyframes ddos-pulse {
            0% { box-shadow: 0 0 18px var(--red-error), inset 0 0 10px rgba(255, 82, 82, 0.5); }
            50% { box-shadow: 0 0 8px var(--red-error), inset 0 0 4px rgba(255, 82, 82, 0.2); }
            100% { box-shadow: 0 0 18px var(--red-error), inset 0 0 10px rgba(255, 82, 82, 0.5); }
        }
        @keyframes ddos-packet-flow {
            from { opacity: 1; }
            to { opacity: 0; transform: translate(var(--tx), var(--ty)); }
        }
        
        @keyframes ddos-cable-flow {
            to { stroke-dashoffset: -100; }
        }
        
        /* New Anti-DDoS Animations */
        @keyframes clean-signal-flow {
            to { stroke-dashoffset: -100; }
        }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--bg-dark);
            color: var(--text-light);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        .container {
            display: flex;
            width: 95%; max-width: 1600px; height: 90vh;
            background-color: var(--bg-light); border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border-color);
            position: relative;
        }

        .workspace {
            flex-grow: 1; position: relative; overflow: hidden;
            background-image: radial-gradient(var(--border-color) 1px, transparent 1px);
            background-size: 20px 20px;
        }
        
        #cable-svg {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%; pointer-events: none;
        }
        #cable-svg line {
            pointer-events: all; cursor: pointer;
            transition: opacity 0.4s ease-in-out, stroke 0.3s linear;
        }
        
        #ddos-packet-container {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            overflow: hidden;
        }

        .ddos-packet {
            position: absolute;
            width: 6px;
            height: 6px;
            background-color: var(--secondary-yellow);
            border-radius: 50%;
            box-shadow: 0 0 8px var(--secondary-yellow);
            animation-name: ddos-packet-flow;
            animation-timing-function: linear;
            animation-fill-mode: forwards;
        }

        .scrub-packet-in { /* New class for scrubbing visualization */
            position: absolute;
            width: 5px;
            height: 5px;
            background-color: var(--red-error);
            border-radius: 50%;
            box-shadow: 0 0 6px var(--red-error);
            animation-name: ddos-packet-flow;
            animation-timing-function: linear;
            animation-fill-mode: forwards;
        }

        .cable-ping {
            stroke: var(--secondary-yellow); stroke-width: 4px;
            stroke-dasharray: 8 12; stroke-dashoffset: 200;
            animation: data-flow 1.5s linear forwards;
            pointer-events: none;
        }
        
        .cable-under-ddos {
            stroke: var(--red-error);
            stroke-dasharray: 10 15;
            animation: ddos-cable-flow 1s linear infinite;
        }

        .cable-clean-signal { /* New class for clean traffic visualization */
            stroke: var(--green-success);
            stroke-width: 5px;
            stroke-dasharray: 8 10;
            animation: clean-signal-flow 1.2s linear infinite;
        }

        .ping-packet-text {
            font-family: 'Courier New', Courier, monospace;
            font-size: 12px;
            font-weight: bold;
            fill: var(--secondary-yellow);
            pointer-events: none;
            text-anchor: middle;
        }


        .device {
            background-color: var(--bg-dark); border: 2px solid var(--border-color);
            border-radius: 8px; padding: 8px; text-align: center;
            width: 100px; height: 125px; 
            display: flex; flex-direction: column; justify-content: space-around;
            position: absolute; user-select: none; cursor: grab;
            transition: box-shadow 0.3s, border-color 0.3s, opacity 0.4s ease-in-out, height 0.3s;
        }
        .device:hover { border-color: var(--primary-blue); }
        .device.selected-for-connection { border-color: var(--secondary-yellow); box-shadow: 0 0 15px var(--secondary-yellow); }
        .device.ip-conflict { border-style: dashed; animation: blink-error 1.5s infinite; }
        .device.highlight { animation: highlight-success 1s ease-out; }
        .device.ping-source { border-color: var(--primary-blue); box-shadow: 0 0 15px var(--primary-blue); }
        
        .device.ddos-server {
            border-color: var(--ddos-color);
            background-color: #3f2a3a;
        }
        .device.under-ddos {
            animation: ddos-pulse 1s infinite;
            border-color: var(--red-error);
        }
        .device.ddos-protected {
            border-color: var(--primary-blue);
            box-shadow: 0 0 15px var(--primary-blue), inset 0 0 8px rgba(13, 110, 253, 0.5);
        }
        
        .device.vpn-protected {
            border-color: var(--green-success);
            box-shadow: 0 0 15px var(--green-success), inset 0 0 8px rgba(67, 160, 71, 0.5);
        }

        .device.device-ddos-victim {
            opacity: 0.6;
            border-color: var(--red-error);
            pointer-events: none;
        }

        .device-icon { font-size: 2rem; }
        .device-name { font-weight: bold; margin: 4px 0; font-size: 14px; }
        .ip-input {
            width: 90%; background-color: var(--bg-light); border: 1px solid var(--border-color);
            color: var(--text-light); border-radius: 4px; padding: 3px;
            text-align: center; font-family: 'Courier New', Courier, monospace; font-size: 11px;
            margin-bottom: 3px;
            cursor: text;
        }
        
        .public-ip-display {
            font-family: 'Courier New', Courier, monospace;
            font-size: 11px; color: var(--secondary-yellow); padding: 3px;
            background-color: #111118; border-radius: 4px; width: 90%;
            margin: 0 auto; min-height: 19px; box-sizing: border-box;
        }

        .public-ip-on-device {
            font-family: 'Courier New', Courier, monospace;
            font-size: 10px;
            color: var(--secondary-yellow);
            background-color: #2c2e43;
            border-radius: 3px;
            padding: 2px 4px;
            margin-top: 2px;
            max-width: 90%;
            margin-left: auto;
            margin-right: auto;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            box-sizing: border-box;
            min-height: 17px;
            transition: color 0.3s;
        }
        
        .device-screen {
            position: absolute; top: 25px; left: 50%;
            transform: translateX(-50%); width: 65px; height: 40px;
            background-color: rgba(0,0,0,0.7); border-radius: 4px;
            z-index: 2; pointer-events: none; transition: all 0.5s;
            opacity: 0; display: flex; align-items: center; justify-content: center;
        }
        .device.has-connection .device-screen { opacity: 1; }
        
        .screen-internet {
            background-image: url('https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png');
            background-size: contain; background-repeat: no-repeat;
            background-position: center; background-color: #fff;
            background-position: 1px;
        }

        .screen-internet-icon {
            background-color: var(--bg-dark);
        }
        .screen-internet-icon::before {
            content: "üåê";
            font-size: 50px;
            color: var(--primary-blue);
        }
        
        .screen-lan-only::before {
            content: "NO INTERNET\A USE LAN"; white-space: pre-wrap;
            color: var(--secondary-yellow); font-size: 8px; font-weight: bold;
            text-align: center; line-height: 1.2;
        }
        
        .screen-ip-conflict-visuals {
            background-color: var(--red-error) !important;
        }
        .screen-ip-conflict-visuals::before {
            content: "TR√ôNG IP";
            color: var(--secondary-yellow);
            font-size: 14px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }
        
        .device.under-ddos .device-screen {
             opacity: 1;
             background-color: var(--ddos-color) !important;
        }
        .device.under-ddos .device-screen::before {
            content: "OVERLOAD!\A(DDoS)"; white-space: pre-wrap;
            color: white; font-size: 12px; font-weight: bold;
            text-shadow: 1px 1px 2px black;
            text-align: center;
        }

        .device.device-ddos-victim .device-screen {
            opacity: 1;
            background: var(--red-error) !important;
        }
        .device.device-ddos-victim .device-screen::before {
            content: "M·∫§T K·∫æT N·ªêI";
            color: white;
            font-weight: bold;
            font-size: 10px;
            text-align: center;
        }

        .remove-btn, .ping-btn, .connect-btn {
            position: absolute; color: white; border: none; border-radius: 50%;
            width: 20px; height: 20px; font-weight: bold; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            opacity: 0; transition: opacity 0.2s; z-index: 10;
        }
        .remove-btn { top: -7px; right: -7px; background: var(--red-error); }
        .ping-btn { bottom: -7px; right: -7px; background: var(--primary-blue); font-size: 12px; }
        .connect-btn { bottom: -7px; left: -7px; background: var(--secondary-yellow); font-size: 12px; }
        .device:hover .remove-btn, .device:hover .ping-btn, .device:hover .connect-btn { opacity: 1; }

        .controls-panel { flex-basis: 350px; flex-shrink: 0; background-color: var(--bg-dark); padding: 20px; border-left: 1px solid var(--border-color); display: flex; flex-direction: column; overflow-y: auto; }
        .controls-panel h3 { margin-top: 0; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
        .io-buttons { display: flex; gap: 10px; margin-bottom: 15px; }
        .io-buttons button { flex-grow: 1; padding: 10px; font-size: 1rem; color: white; border: none; border-radius: 8px; cursor: pointer; transition: background-color 0.2s; }
        #export-btn { background-color: var(--import-color); }
        #import-btn { background-color: var(--export-color); }
        
        .control-buttons button, .batch-controls button { width: 100%; padding: 12px; font-size: 1rem; color: white; border: none; border-radius: 8px; cursor: pointer; margin-bottom: 10px; transition: background-color 0.2s, opacity 0.2s; }
        
        .controls-panel select {
            width: 100%;
            padding: 12px;
            font-size: 1rem;
            color: var(--text-light);
            background-color: var(--bg-light);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            margin-bottom: 10px;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23e0e0e0' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M2 5l6 6 6-6'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 1rem center;
            background-size: 1em;
        }

        #add-selected-device-btn { background-color: var(--primary-blue); }
        #auto-ip-btn { background-color: var(--green-success); }
        #add-ddos-btn { background-color: var(--ddos-color); }
        
        .batch-controls { margin-top: 15px; }
        .batch-controls input { width: calc(100% - 22px); padding: 12px; margin-bottom: 10px; border-radius: 8px; border: 1px solid var(--border-color); background: var(--bg-light); color: var(--text-light); font-size: 1rem; }
        .log-panel { margin-top: 20px; flex-grow: 1; background-color: #111118; border-radius: 8px; padding: 15px; overflow-y: auto; font-family: 'Courier New', Courier, monospace; font-size: 13px; min-height: 150px; }
        #log-list { list-style-type: none; padding: 0; margin: 0; }
        #log-list li { padding: 4px 0; border-bottom: 1px dashed var(--border-color); word-break: break-word; }
        .log-success { color: var(--green-success); }
        .log-error { color: var(--red-error); font-weight: bold; }
        .log-info { color: var(--text-light); }
        .log-warn { color: var(--secondary-yellow); }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); display: none; justify-content: center; align-items: center; z-index: 2000; }
        .modal-content { background: var(--bg-light); padding: 25px; border-radius: 15px; width: 90%; max-width: 700px; max-height: 80vh; border: 1px solid var(--border-color); display: flex; flex-direction: column; }
        .modal-content h4 { margin-top: 0; color: var(--secondary-yellow); }
        #cable-context-menu { position: absolute; background-color: var(--bg-dark); border: 1px solid var(--border-color); border-radius: 5px; padding: 5px; z-index: 3000; }
        #cable-context-menu button { background: none; border: none; color: var(--red-error); padding: 8px 12px; cursor: pointer; width: 100%; text-align: left; }
        #cable-context-menu button:hover { background-color: var(--red-error); color: white; }
        .workspace.ping-isolation-mode .device:not(.ping-active) { opacity: 0.1; pointer-events: none; }
        #cable-svg.ping-isolation-mode line:not(.ping-active) { opacity: 0.05; }
        .device.ping-active { box-shadow: 0 0 20px var(--primary-blue); border-color: var(--primary-blue); z-index: 1001; }
        #ping-overlay { position: absolute; bottom: 10px; left: 10px; width: calc(100% - 20px); max-width: 500px;  background: rgba(20, 20, 30, 0.85); border: 1px solid var(--border-color); backdrop-filter: blur(5px); border-radius: 8px; z-index: 1500; padding: 15px; display: none; flex-direction: column; box-sizing: border-box; }
        #ping-log-display { font-family: 'Courier New', Courier, monospace; color: white; font-size: 14px; height: 120px; overflow-y: auto; background-color: #111118; padding: 10px; border-radius: 5px; margin-bottom: 10px; }
        #ping-log-display p { margin: 0 0 5px 0; }
        #cancel-ping-btn { background-color: var(--red-error); color: white; border: none; padding: 10px; border-radius: 5px; cursor: pointer; font-weight: bold; }
        #device-info-modal .modal-content, #connection-modal .modal-content { max-width: 450px; }
        #device-info-modal h4, #connection-modal h4 { text-align: center; font-size: 1.2rem; }
        .info-grid { display: grid; grid-template-columns: 120px 1fr; gap: 12px; font-size: 1rem; margin-bottom: 20px; font-family: 'Courier New', Courier, monospace; }
        .info-grid span:first-child { font-weight: bold; text-align: right; color: var(--secondary-yellow); }
        .info-grid span:last-child { background-color: #111118; padding: 5px 8px; border-radius: 4px; word-break: break-all; }
        .vpn-control { display: flex; align-items: center; justify-content: center; gap: 15px; margin: 10px 0 20px 0; }
        .switch { position: relative; display: inline-block; width: 60px; height: 34px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--green-success); }
        input:focus + .slider { box-shadow: 0 0 1px var(--green-success); }
        input:checked + .slider:before { transform: translateX(26px); }
        #info-modal-close-btn { background-color: var(--red-error); margin-top: 10px; color:white; border:none; padding: 10px; border-radius: 8px; cursor:pointer; }
        .vpn-info-label, #info-vpn-ip { display: none; }
        .modal-filters { display: flex; gap: 10px; margin-bottom: 15px; }
        .modal-filters button { flex-grow: 1; padding: 8px; border: 1px solid var(--border-color); background: var(--bg-dark); color: var(--text-light); border-radius: 6px; cursor: pointer; transition: background-color 0.2s; }
        .modal-filters button:hover { background-color: #3a3c53; }
        .modal-filters button.active { background-color: var(--primary-blue); border-color: var(--primary-blue); color: white; }
        #device-selection-list { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 15px; overflow-y: auto; padding: 10px; border: 1px solid var(--border-color); border-radius: 8px; flex-grow: 1; margin-bottom: 20px; min-height: 100px; }
        .device-list-item { background: var(--bg-dark); padding: 10px; border-radius: 8px; cursor: pointer; text-align: center; border: 2px solid transparent; transition: border-color 0.2s, background-color 0.2s; font-size: 14px; }
        .device-list-item:hover { border-color: var(--primary-blue); }
        .device-list-item.selected { border-color: var(--secondary-yellow); background-color: #3a3c53; }
        .modal-buttons { display: flex; gap: 10px; flex-wrap: wrap; }
        .modal-buttons button { padding: 10px 15px; color: white; border: none; border-radius: 8px; cursor: pointer; transition: background-color 0.2s; flex-grow: 1; }
        #connect-selected-btn { background-color: var(--primary-blue); }
        #connect-all-btn { background-color: var(--green-success); }
        #cancel-connect-btn { background-color: var(--red-error); }
        
        #help-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 1px solid var(--border-color);
            background: var(--bg-light);
            color: var(--secondary-yellow);
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            z-index: 1002;
            transition: background-color 0.2s, color 0.2s;
        }
        #help-btn:hover {
            background-color: var(--secondary-yellow);
            color: var(--bg-dark);
        }
        #help-content {
            flex-grow: 1;
            overflow-y: auto;
            margin-bottom: 20px;
            font-size: 14px;
            line-height: 1.6;
        }
        #help-content ul {
            list-style-type: none;
            padding-left: 0;
        }
        #help-content li {
            padding: 8px 0;
            border-bottom: 1px dashed var(--border-color);
        }
        #help-content li:last-child {
            border-bottom: none;
        }
        #help-content strong {
            color: var(--secondary-yellow);
        }
        #help-modal-close-btn {
            background-color: var(--primary-blue);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            width: 100%;
        }

        /* VLAN Modal Styles */
        #vlan-modal .modal-content {
            max-width: 600px;
        }
        .vlan-section {
            background-color: var(--bg-dark);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }
        .vlan-section h5 {
            margin: 0 0 10px 0;
            color: var(--primary-blue);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 8px;
        }
        #vlan-creator {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        #vlan-creator input {
            flex-grow: 1;
            padding: 8px;
            background-color: var(--bg-light);
            border: 1px solid var(--border-color);
            color: var(--text-light);
            border-radius: 5px;
        }
        #vlan-creator button {
            padding: 8px 12px;
            background-color: var(--green-success);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #vlan-port-assignments {
            max-height: 250px;
            overflow-y: auto;
            padding-right: 10px;
        }
        .vlan-port-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px dashed var(--border-color);
        }
        .vlan-port-item:last-child {
            border-bottom: none;
        }
        .vlan-port-item span {
            font-family: 'Courier New', Courier, monospace;
        }
        .vlan-port-item select {
            background-color: var(--bg-light);
            border: 1px solid var(--border-color);
            color: var(--text-light);
            border-radius: 5px;
            padding: 5px;
        }
        .vlan-modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
         .vlan-modal-buttons button {
           flex-grow: 1;
         }
    </style>
</head>
<body>

<div class="container">
    <button id="help-btn" title="H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng">?</button>

    <div class="workspace" id="workspace">
        <svg id="cable-svg"></svg>
        <div id="ddos-packet-container"></div>
        <div id="ping-overlay">
            <div id="ping-log-display"></div>
            <button id="cancel-ping-btn">H·ªßy Ping</button>
        </div>
    </div>
    <aside class="controls-panel">
        <h3>B·∫£ng ƒëi·ªÅu khi·ªÉn</h3>
        <div class="io-buttons">
            <button id="import-btn">Nh·∫≠p File üìÇ</button>
            <button id="export-btn">Xu·∫•t File üíæ</button>
        </div>
        <h3>Nh·∫≠t k√Ω h·ªá th·ªëng</h3>
        <div class="log-panel"><ul id="log-list"></ul></div>
        <div class="control-buttons">
            <select id="add-device-select">
                <option value="pc">Th√™m PC üíª</option>
                <option value="phone">Th√™m ƒêi·ªán tho·∫°i üì±</option>
                <option value="router">Th√™m Router üñß</option>
                <option value="router-v2">Th√™m Router V2 (VLAN) üñß‚ú®</option>
                <option value="switch">Th√™m Switch üéöÔ∏è</option>
                <option value="firewall">Th√™m T∆∞·ªùng l·ª≠a üõ°Ô∏è</option>
                <option value="anti-ddos-system">Th√™m H·ªá th·ªëng Anti-DDoS üõ°Ô∏è‚ú®</option>
            </select>
            <button id="add-selected-device-btn">Th√™m Thi·∫øt B·ªã</button>
            
            <hr>
            <button id="auto-ip-btn" title="C·∫•p IP cho c√°c thi·∫øt b·ªã ch∆∞a c√≥ IP v√† k·∫øt n·ªëi t·ªõi Router">C·∫•p IP t·ª± ƒë·ªông (DHCP)</button>
            <button id="add-ddos-btn" title="T·∫°o m·ªôt server DDoS. N·ªëi d√¢y server n√†y v√†o Router ƒë·ªÉ b·∫Øt ƒë·∫ßu t·∫•n c√¥ng.">T·∫•n c√¥ng DDoS üíÄ</button>
        </div>
        <div class="batch-controls">
            <h3>Thao t√°c h√†ng lo·∫°t</h3>
            <input type="number" id="multi-pc-count" placeholder="S·ªë l∆∞·ª£ng" value="5" min="1">
            <button id="add-multi-pc-btn" style="background-color: blue;color: white;">Th√™m nhi·ªÅu PC</button>
        </div>
        
    </aside>
</div>

<div id="connection-modal" class="modal-overlay">
    <div class="modal-content">
        <h4 id="modal-title">K·∫øt n·ªëi thi·∫øt b·ªã</h4>
        <div class="modal-filters" id="device-filter-buttons">
            <button data-filter="all" class="active">T·∫•t c·∫£</button>
            <button data-filter="pc">Ch·ªâ PC</button>
            <button data-filter="phone">Ch·ªâ ƒêi·ªán Tho·∫°i</button>
        </div>
        <div id="device-selection-list"></div>
        <div class="modal-buttons">
            <button id="connect-selected-btn">K·∫øt n·ªëi m·ª•c ƒë√£ ch·ªçn</button>
            <button id="connect-all-btn">K·∫øt n·ªëi t·∫•t c·∫£</button>
            <button id="cancel-connect-btn">H·ªßy</button>
        </div>
    </div>
</div>
<div id="device-info-modal" class="modal-overlay">
    <div class="modal-content">
        <h4 id="info-modal-title">Th√¥ng tin thi·∫øt b·ªã</h4>
        <div class="info-grid">
            <span>T√™n thi·∫øt b·ªã:</span><span id="info-device-name"></span>
            <span>IP Private:</span><span id="info-private-ip"></span>
            <span>IP Public:</span><span id="info-public-ip"></span>
            <span class="vpn-info-label">IP Proxy/VPN:</span><span id="info-vpn-ip"></span>
        </div>
        <div class="vpn-control">
            <span><b>VPN Ch·ªëng DDoS:</b></span>
            <label class="switch">
                <input type="checkbox" id="vpn-toggle">
                <span class="slider"></span>
            </label>
            <span id="vpn-status">ƒêang T·∫ÆT</span>
        </div>
        <button id="info-modal-close-btn">ƒê√≥ng</button>
    </div>
</div>

<div id="vlan-modal" class="modal-overlay">
    <div class="modal-content">
        <h4 id="vlan-modal-title">Qu·∫£n l√Ω VLAN</h4>
        <div class="vlan-section">
            <h5>T·∫°o VLAN M·ªõi</h5>
            <div id="vlan-creator">
                <input type="number" id="vlan-id-input" placeholder="VLAN ID (vd: 10)">
                <input type="text" id="vlan-name-input" placeholder="T√™n VLAN (vd: Sales)">
                <button id="add-vlan-btn">Th√™m</button>
            </div>
        </div>
        <div class="vlan-section">
            <h5>G√°n C·ªïng v√†o VLAN</h5>
            <div id="vlan-port-assignments">
                </div>
        </div>
        <div class="vlan-modal-buttons modal-buttons">
            <button id="save-vlan-config" style="background-color: var(--green-success);">L∆∞u C·∫•u H√¨nh</button>
            <button id="cancel-vlan-config" style="background-color: var(--red-error);">H·ªßy</button>
        </div>
    </div>
</div>


<div id="help-modal" class="modal-overlay">
    <div class="modal-content">
        <h4>H∆∞·ªõng D·∫´n S·ª≠ D·ª•ng</h4>
        <div id="help-content">
            <p>Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi c√¥ng c·ª• M√¥ ph·ªèng M·∫°ng!</p>
            <ul>
                <li><strong>Th√™m Thi·∫øt B·ªã:</strong> Ch·ªçn m·ªôt lo·∫°i thi·∫øt b·ªã t·ª´ menu th·∫£ xu·ªëng ·ªü b·∫£ng ƒëi·ªÅu khi·ªÉn v√† nh·∫•n "Th√™m Thi·∫øt B·ªã".</li>
                <li><strong>Di Chuy·ªÉn Thi·∫øt B·ªã:</strong> Nh·∫•n v√† k√©o ph·∫ßn th√¢n c·ªßa m·ªôt thi·∫øt b·ªã ƒë·ªÉ di chuy·ªÉn n√≥ trong kh√¥ng gian l√†m vi·ªác.</li>
                <li><strong>N·ªëi D√¢y:</strong> Di chu·ªôt v√†o thi·∫øt b·ªã, sau ƒë√≥ nh·∫•n v√† k√©o bi·ªÉu t∆∞·ª£ng li√™n k·∫øt (üîó) t·ª´ thi·∫øt b·ªã n√†y sang thi·∫øt b·ªã kh√°c.</li>
                <li><strong>X√≥a Thi·∫øt B·ªã:</strong> Di chu·ªôt v√†o thi·∫øt b·ªã v√† nh·∫•n v√†o n√∫t 'x' m√†u ƒë·ªè.</li>
                <li><strong>X√≥a K·∫øt N·ªëi:</strong> Nh·∫•p chu·ªôt ph·∫£i v√†o m·ªôt ƒë∆∞·ªùng d√¢y c√°p v√† ch·ªçn "X√≥a k·∫øt n·ªëi".</li>
                <li><strong>Ping:</strong> Tr√™n PC ho·∫∑c ƒêi·ªán tho·∫°i, di chu·ªôt v√†o thi·∫øt b·ªã v√† nh·∫•n n√∫t m≈©i t√™n (‚û§), sau ƒë√≥ nh·∫•p v√†o thi·∫øt b·ªã ƒë√≠ch.</li>
                <li><strong>Xem Th√¥ng Tin / VPN:</strong> Nh·∫•p ƒë√∫p chu·ªôt v√†o PC ho·∫∑c ƒêi·ªán tho·∫°i ƒë·ªÉ xem th√¥ng tin chi ti·∫øt v√† b·∫≠t/t·∫Øt VPN Ch·ªëng DDoS.</li>
                <li><strong>Qu·∫£n l√Ω VLAN:</strong> Nh·∫•p ƒë√∫p v√†o m·ªôt <strong>Router V2</strong> ƒë·ªÉ m·ªü b·∫£ng c·∫•u h√¨nh VLAN.</li>
                <li><strong>C·∫•p IP T·ª± ƒê·ªông:</strong> Nh·∫•n n√∫t "C·∫•p IP t·ª± ƒë·ªông (DHCP)" ƒë·ªÉ c√°c Router t·ª± ƒë·ªông c·∫•p IP cho c√°c thi·∫øt b·ªã ƒë∆∞·ª£c k·∫øt n·ªëi.</li>
                <li><strong>T·∫•n C√¥ng DDoS:</strong> Th√™m m·ªôt "DDoS Server" v√† n·ªëi d√¢y n√≥ v√†o m·ªôt Router ƒë·ªÉ b·∫Øt ƒë·∫ßu m√¥ ph·ªèng cu·ªôc t·∫•n c√¥ng.</li>
            </ul>
        </div>
        <button id="help-modal-close-btn">ƒê√£ hi·ªÉu</button>
    </div>
</div>

<input type="file" id="import-file-input" style="display: none;" accept=".json">

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- DOM Element References ---
    const workspace = document.getElementById('workspace');
    const cableSvg = document.getElementById('cable-svg');
    const ddosPacketContainer = document.getElementById('ddos-packet-container');
    const logList = document.getElementById('log-list');
    
    const addDeviceSelect = document.getElementById('add-device-select');
    const addSelectedDeviceBtn = document.getElementById('add-selected-device-btn');
    const addDdosBtn = document.getElementById('add-ddos-btn');
    
    const autoIpBtn = document.getElementById('auto-ip-btn');
    const addMultiPcBtn = document.getElementById('add-multi-pc-btn');
    const multiPcCountInput = document.getElementById('multi-pc-count');
    const exportBtn = document.getElementById('export-btn');
    const importBtn = document.getElementById('import-btn');
    const importFileInput = document.getElementById('import-file-input');

    const pingOverlay = document.getElementById('ping-overlay');
    const pingLogDisplay = document.getElementById('ping-log-display');
    const cancelPingBtn = document.getElementById('cancel-ping-btn');

    const connectionModal = document.getElementById('connection-modal');
    const modalTitle = document.getElementById('modal-title');
    const deviceSelectionList = document.getElementById('device-selection-list');
    const connectSelectedBtn = document.getElementById('connect-selected-btn');
    const connectAllBtn = document.getElementById('connect-all-btn');
    const cancelConnectBtn = document.getElementById('cancel-connect-btn');
    const deviceFilterButtons = document.getElementById('device-filter-buttons');

    const deviceInfoModal = document.getElementById('device-info-modal');
    const infoModalTitle = document.getElementById('info-modal-title');
    const infoDeviceName = document.getElementById('info-device-name');
    const infoPrivateIp = document.getElementById('info-private-ip');
    const infoPublicIp = document.getElementById('info-public-ip');
    const vpnToggle = document.getElementById('vpn-toggle');
    const vpnStatus = document.getElementById('vpn-status');
    const infoModalCloseBtn = document.getElementById('info-modal-close-btn');

    const vlanModal = document.getElementById('vlan-modal');
    const vlanModalTitle = document.getElementById('vlan-modal-title');
    const vlanIdInput = document.getElementById('vlan-id-input');
    const vlanNameInput = document.getElementById('vlan-name-input');
    const addVlanBtn = document.getElementById('add-vlan-btn');
    const vlanPortAssignments = document.getElementById('vlan-port-assignments');
    const saveVlanConfigBtn = document.getElementById('save-vlan-config');
    const cancelVlanConfigBtn = document.getElementById('cancel-vlan-config');

    const helpBtn = document.getElementById('help-btn');
    const helpModal = document.getElementById('help-modal');
    const helpModalCloseBtn = document.getElementById('help-modal-close-btn');

    // --- State Variables ---
    let devices = {};
    let cables = {};
    let idCounter = 0;
    let deviceCounters = {};
    let cableCounter = 0;
    
    let draggedDevice = null;
    let offsetX, offsetY;
    let isPingMode = false;
    let pingInProgress = false;
    let pingSourceDevice = null;
    let pingTimeoutId = null;
    let ddosIntervals = {};
    let scrubbingIntervals = {}; // New state for scrubbing animation

    let isConnecting = false;
    let connectionSourceId = null;
    let tempCableLine = null;
    
    const vlanColors = [
        '--vlan-color-1', '--vlan-color-2', '--vlan-color-3', '--vlan-color-4',
        '--vlan-color-5', '--vlan-color-6', '--vlan-color-7', '--vlan-color-8'
    ];
    
    // --- Core Functions ---
    const addLog = (message, type = 'info') => {
        const li = document.createElement('li');
        li.textContent = `> ${message}`;
        li.className = `log-${type}`;
        logList.prepend(li);
        if (logList.children.length > 200) {
            logList.removeChild(logList.lastChild);
        }
    };
    
    const stopDdosAnimation = (ddosId) => {
        if (ddosIntervals[ddosId]) {
            clearInterval(ddosIntervals[ddosId]);
            delete ddosIntervals[ddosId];
        }
    };

    // New function to stop scrubbing animation
    const stopScrubbingAnimation = (routerId) => {
        if (scrubbingIntervals[routerId]) {
            clearInterval(scrubbingIntervals[routerId]);
            delete scrubbingIntervals[routerId];
        }
    };

    const clearWorkspace = () => {
        Object.values(devices).forEach(d => {
            if (d.attackTimeoutId) clearTimeout(d.attackTimeoutId);
            workspace.removeChild(d.element);
        });
        cableSvg.innerHTML = '';
        ddosPacketContainer.innerHTML = '';
        Object.keys(ddosIntervals).forEach(stopDdosAnimation);
        Object.keys(scrubbingIntervals).forEach(stopScrubbingAnimation); // Clear scrubbing anims
        devices = {};
        cables = {};
        ddosIntervals = {};
        scrubbingIntervals = {};
        idCounter = 0;
        deviceCounters = {};
        cableCounter = 0;
        logList.innerHTML = '';
        addLog("Kh√¥ng gian l√†m vi·ªác ƒë√£ ƒë∆∞·ª£c d·ªçn d·∫πp.", "info");
    };
    
    const createDeviceElement = (devData) => {
        const deviceElement = document.createElement('div');
        deviceElement.className = 'device';
        deviceElement.id = devData.id;
        deviceElement.style.left = devData.left;
        deviceElement.style.top = devData.top;

        if (devData.type === 'ddos') {
            deviceElement.classList.add('ddos-server');
        }

        const icons = { pc: 'üíª', phone: 'üì±', router: 'üñß', 'router-v2': 'üñß‚ú®', switch: 'üéöÔ∏è', ddos: 'üíÄ', firewall: 'üõ°Ô∏è', 'anti-ddos-system': 'üõ°Ô∏è‚ú®' };
        const icon = icons[devData.type] || '?';
        let ipFieldHtml = '';
        if (devData.type === 'router' || devData.type === 'router-v2') {
            deviceElement.style.height = '110px';
            ipFieldHtml = '<div class="public-ip-display" title="IP Public">Ch∆∞a c√≥ IP</div>';
        } else if (devData.ipEnabled) {
            ipFieldHtml = `
                <input type="text" class="ip-input" placeholder="IP Private" value="${devData.privateIp || ''}">
                <div class="public-ip-on-device" title="IP Public (t·ª´ Router)">Ch∆∞a k·∫øt n·ªëi</div>
            `;
        } else {
             deviceElement.style.height = '110px';
        }
        deviceElement.innerHTML = `
            <button class="remove-btn" title="X√≥a thi·∫øt b·ªã">x</button>
            <button class="connect-btn" title="N·ªëi d√¢y t·ªõi thi·∫øt b·ªã kh√°c">üîó</button>
            ${ (devData.type === 'pc' || devData.type === 'phone') ? `<button class="ping-btn" title="Ping ƒë·∫øn thi·∫øt b·ªã kh√°c">‚û§</button>` : '' }
            <div class="device-icon">${icon}</div>
            <div class="device-screen"></div>
            <div class="device-info">
                <p class="device-name">${devData.name}</p>
                ${ipFieldHtml}
            </div>
        `;
        deviceElement.querySelector('.remove-btn').addEventListener('click', e => { e.stopPropagation(); removeDevice(devData.id); });
        deviceElement.querySelector('.connect-btn').addEventListener('mousedown', onConnectStart);
        
        const pingBtn = deviceElement.querySelector('.ping-btn');
        if (pingBtn) pingBtn.addEventListener('click', e => { e.stopPropagation(); startPing(devData.id); });
        
        const ipInput = deviceElement.querySelector('.ip-input');
        if (ipInput) ipInput.addEventListener('blur', handleManualIpChange);

        deviceElement.addEventListener('mousedown', onMouseDown);
        deviceElement.addEventListener('click', onDeviceClick);
        deviceElement.addEventListener('dblclick', onDeviceDoubleClick);
        return deviceElement;
    };

    const addDevice = (type, name, ipEnabled = true) => {
        idCounter++;
        const deviceId = `device-${idCounter}`;

        if (!deviceCounters[type]) {
            deviceCounters[type] = 0;
        }
        deviceCounters[type]++;
        const deviceName = `${name}-${deviceCounters[type]}`;

        const workspaceRect = workspace.getBoundingClientRect();
        const deviceWidthWithMargin = 120;
        const deviceHeightWithMargin = 145;
        const itemsPerRow = Math.floor((workspaceRect.width - 20) / deviceWidthWithMargin) || 1;
        const currentDeviceCount = Object.keys(devices).length;
        const left = `${(currentDeviceCount % itemsPerRow) * deviceWidthWithMargin + 10}px`;
        const top = `${Math.floor(currentDeviceCount / itemsPerRow) * deviceHeightWithMargin + 10}px`;

        const devData = { id: deviceId, name: deviceName, type, ipEnabled, left, top, privateIp: null };
        const deviceElement = createDeviceElement(devData);
        workspace.appendChild(deviceElement);
        
        const deviceObject = { 
            element: deviceElement, name: deviceName, type: type, 
            ipEnabled: ipEnabled, privateIp: null, publicIp: null,
            vpnEnabled: false, vpnIp: null, connectedRouterId: null,
            isAttacking: false, attackTimeoutId: null
        };
        
        if (type === 'router-v2') {
            deviceObject.vlans = []; // Array of {id, name}
            deviceObject.vlanAssignments = {}; // { cableId: vlanId }
        }
        
        devices[deviceId] = deviceObject;

        addLog(`ƒê√£ t·∫°o ${deviceName}.`, 'info');
        updateAllDeviceStates();
        if (type === 'router' || type === 'router-v2' || type === 'switch') {
            showConnectionModal(deviceId, deviceName);
        }
    };
    
    const removeDevice = (deviceId) => {
        const device = devices[deviceId];
        if (!device) return;
        if (device.attackTimeoutId) clearTimeout(device.attackTimeoutId);
        if (device.type === 'ddos') {
            stopDdosAnimation(deviceId);
        }
        Object.keys(cables).forEach(cableId => {
            if (cables[cableId].from === deviceId || cables[cableId].to === deviceId) {
                removeCable(cableId, false); // false to prevent recursive update calls
            }
        });
        addLog(`ƒê√£ x√≥a ${device.name}.`, 'warn');
        workspace.removeChild(device.element);
        delete devices[deviceId];
        updateAllDeviceStates();
    };

    const getConnectedProtectionDevice = (routerId, protectionType) => {
        for (const cable of Object.values(cables)) {
            let neighborId = null;
            if (cable.from === routerId) neighborId = cable.to;
            else if (cable.to === routerId) neighborId = cable.from;

            if (neighborId && devices[neighborId] && devices[neighborId].type === protectionType) {
                return neighborId; // Return the ID of the protection device
            }
        }
        return null;
    };
    
    const isRouterScrubbed = (routerId) => !!getConnectedProtectionDevice(routerId, 'anti-ddos-system');
    const isRouterProtectedByFirewall = (routerId) => !!getConnectedProtectionDevice(routerId, 'firewall');

    // New animation function for scrubbing effect
    const startScrubbingAnimation = (routerId, antiDdosId) => {
        if (scrubbingIntervals[routerId]) return;

        const routerDevice = devices[routerId]?.element;
        const antiDdosDevice = devices[antiDdosId]?.element;
        if (!routerDevice || !antiDdosDevice) return;

        scrubbingIntervals[routerId] = setInterval(() => {
            if (!devices[routerId] || !devices[antiDdosId]) {
                stopScrubbingAnimation(routerId);
                return;
            }
            const routerRect = routerDevice.getBoundingClientRect();
            const antiDdosRect = antiDdosDevice.getBoundingClientRect();
            const workspaceRect = workspace.getBoundingClientRect();

            const startX = routerRect.left + routerRect.width / 2 - workspaceRect.left + (Math.random() - 0.5) * 40;
            const startY = routerRect.top + routerRect.height / 2 - workspaceRect.top + (Math.random() - 0.5) * 40;
            const endX = antiDdosRect.left + antiDdosRect.width / 2 - workspaceRect.left;
            const endY = antiDdosRect.top + antiDdosRect.height / 2 - workspaceRect.top;

            const packet = document.createElement('div');
            packet.className = 'scrub-packet-in';
            packet.style.left = `${startX}px`;
            packet.style.top = `${startY}px`;
            
            const translateX = endX - startX;
            const translateY = endY - startY;
            const distance = Math.sqrt(translateX * translateX + translateY * translateY);
            const duration = distance / 250; 

            packet.style.setProperty('--tx', `${translateX}px`);
            packet.style.setProperty('--ty', `${translateY}px`);
            packet.style.animationDuration = `${Math.max(0.3, duration)}s`;
            
            ddosPacketContainer.appendChild(packet);
            packet.addEventListener('animationend', () => packet.remove());
        }, 120);
    };

    const startDdosAnimation = (ddosId, routerId) => {
        if (ddosIntervals[ddosId]) return;
        const ddosDevice = devices[ddosId]?.element;
        const routerDevice = devices[routerId]?.element;
        if (!ddosDevice || !routerDevice) return;

        ddosIntervals[ddosId] = setInterval(() => {
            if (!devices[ddosId] || !devices[routerId]) {
                 stopDdosAnimation(ddosId);
                 return;
            }
            const ddosRect = ddosDevice.getBoundingClientRect();
            const routerRect = routerDevice.getBoundingClientRect();
            const workspaceRect = workspace.getBoundingClientRect();
            const startX = ddosRect.left + ddosRect.width / 2 - workspaceRect.left + (Math.random() - 0.5) * 40;
            const startY = ddosRect.top + ddosRect.height / 2 - workspaceRect.top + (Math.random() - 0.5) * 40;
            const endX = routerRect.left + routerRect.width / 2 - workspaceRect.left + (Math.random() - 0.5) * 50;
            const endY = routerRect.top + routerRect.height / 2 - workspaceRect.top + (Math.random() - 0.5) * 50;
            const packet = document.createElement('div');
            packet.className = 'ddos-packet';
            packet.style.left = `${startX}px`;
            packet.style.top = `${startY}px`;
            const translateX = endX - startX;
            const translateY = endY - startY;
            const distance = Math.sqrt(translateX*translateX + translateY*translateY);
            const duration = distance / (300 + Math.random() * 100);
            packet.style.setProperty('--tx', `${translateX}px`);
            packet.style.setProperty('--ty', `${translateY}px`);
            packet.style.animationDuration = `${Math.max(0.3, duration)}s`;
            ddosPacketContainer.appendChild(packet);
            packet.addEventListener('animationend', () => packet.remove());
        }, 80);
    };
    
    const updateDdosState = () => {
        document.querySelectorAll('.cable-under-ddos, .device-ddos-victim, .under-ddos, .ddos-protected, .vpn-protected, .cable-clean-signal').forEach(el => {
            el.classList.remove('cable-under-ddos', 'device-ddos-victim', 'under-ddos', 'ddos-protected', 'vpn-protected', 'cable-clean-signal');
        });

        // Stop all scrubbing animations before re-evaluating
        Object.keys(scrubbingIntervals).forEach(stopScrubbingAnimation);

        const attackedRouterIds = new Set();
        const scrubbedRouterIds = new Set();

        Object.values(devices).filter(d => d.type === 'ddos').forEach(ddosServer => {
            const ddosId = ddosServer.element.id;
            const connection = Object.values(cables).find(c => c.from === ddosId || c.to === ddosId);
            
            let isActivelyAttacking = false;

            if (connection) {
                const neighborId = connection.from === ddosId ? connection.to : connection.from;
                const neighbor = devices[neighborId];

                if (neighbor && (neighbor.type === 'router' || neighbor.type === 'router-v2')) {
                    if (isRouterScrubbed(neighborId)) {
                        const antiDdosId = getConnectedProtectionDevice(neighborId, 'anti-ddos-system');
                        scrubbedRouterIds.add(neighborId);
                        if (!ddosServer.isAttacking) {
                            addLog(`üõ°Ô∏è‚ú® H·ªá th·ªëng Anti-DDoS ƒëang l·ªçc l∆∞u l∆∞·ª£ng t·∫•n c√¥ng v√†o ${neighbor.name}.`, 'success');
                        }
                        startDdosAnimation(ddosId, neighborId);
                        startScrubbingAnimation(neighborId, antiDdosId); // Start new scrubbing animation
                        
                        // Add class for clean signal cable
                        const cleanSignalCable = Object.values(cables).find(c => (c.from === neighborId && c.to === antiDdosId) || (c.to === neighborId && c.from === antiDdosId));
                        if(cleanSignalCable) {
                            cleanSignalCable.element.classList.add('cable-clean-signal');
                        }

                        isActivelyAttacking = true;

                    } else if (isRouterProtectedByFirewall(neighborId)) {
                        if (ddosServer.isAttacking) {
                            addLog(`üõ°Ô∏è T·∫•n c√¥ng v√†o ${neighbor.name} ƒë√£ b·ªã T∆∞·ªùng l·ª≠a ch·∫∑n!`, 'success');
                        }
                        isActivelyAttacking = false;

                    } else {
                        attackedRouterIds.add(neighborId);
                        isActivelyAttacking = true;
                        if (!ddosServer.isAttacking) {
                            ddosServer.isAttacking = true;
                            const delay = Math.random() * 2000 + 2000;
                            addLog(`üî• Server ${ddosServer.name} nh·∫Øm v√†o ${neighbor.name}. T·∫•n c√¥ng sau ${(delay / 1000).toFixed(1)}s...`, 'warn');
                            
                            if (ddosServer.attackTimeoutId) clearTimeout(ddosServer.attackTimeoutId);
                            ddosServer.attackTimeoutId = setTimeout(() => {
                                if (!devices[ddosId] || !devices[neighborId]) return;
                                addLog(`üî• B·∫ÆT ƒê·∫¶U T·∫§N C√îNG: ${ddosServer.name} -> ${neighbor.name}!`, 'error');
                                updateAllDeviceStates();
                            }, delay);
                        }
                        startDdosAnimation(ddosId, neighborId);
                    }
                }
            }
            
            if (!isActivelyAttacking) {
                if (ddosServer.isAttacking) addLog(`üõë Cu·ªôc t·∫•n c√¥ng t·ª´ ${ddosServer.name} ƒë√£ d·ª´ng.`, 'warn');
                stopDdosAnimation(ddosId);
                if (ddosServer.attackTimeoutId) clearTimeout(ddosServer.attackTimeoutId);
                ddosServer.attackTimeoutId = null;
                ddosServer.isAttacking = false;
            } else {
                ddosServer.isAttacking = true;
            }
        });

        attackedRouterIds.forEach(routerId => devices[routerId].element.classList.add('under-ddos'));
        scrubbedRouterIds.forEach(routerId => devices[routerId].element.classList.add('ddos-protected'));
        
        Object.values(devices).forEach(device => {
            if (attackedRouterIds.has(device.connectedRouterId) && device.type !== 'router' && device.type !== 'router-v2' && device.type !== 'switch' && device.type !== 'ddos' && device.type !== 'firewall' && device.type !== 'anti-ddos-system') {
                 if (device.vpnEnabled) {
                     device.element.classList.add('vpn-protected');
                     if (!device.element.dataset.notifiedProtected) {
                         addLog(`‚úÖ ${device.name} ƒë∆∞·ª£c b·∫£o v·ªá b·ªüi VPN ri√™ng.`, 'success');
                         device.element.dataset.notifiedProtected = true;
                     }
                 } else {
                     device.element.classList.add('device-ddos-victim');
                     delete device.element.dataset.notifiedProtected;
                 }
            } else {
                 delete device.element.dataset.notifiedProtected;
            }
        });


        Object.values(cables).forEach(cable => {
            const fromDevice = devices[cable.from];
            const toDevice = devices[cable.to];
            const isFromAffected = fromDevice && (attackedRouterIds.has(fromDevice.element.id) || fromDevice.element.classList.contains('device-ddos-victim'));
            const isToAffected = toDevice && (attackedRouterIds.has(toDevice.element.id) || toDevice.element.classList.contains('device-ddos-victim'));

            if (isFromAffected || isToAffected) {
                cable.element.classList.add('cable-under-ddos');
            }
        });
    };
    
    const updateAllDeviceStates = () => {
        Object.values(devices).forEach(d => {
            d.publicIp = null;
            d.connectedRouterId = null;
        });
        const allRouters = Object.values(devices).filter(dev => dev.type === 'router' || dev.type === 'router-v2');
        allRouters.forEach(router => {
            if (!router.publicIp) {
                router.publicIp = `118.70.${Math.floor(Math.random() * 254) + 1}.${Math.floor(Math.random() * 254) + 1}`;
            }
            if(router.element.querySelector('.public-ip-display')) {
                router.element.querySelector('.public-ip-display').textContent = router.publicIp;
            }
            // Use a proper pathfinding algorithm to assign public IP
            const reachableDevices = findReachableDevices(router.element.id);
            reachableDevices.forEach(devId => {
                 if(devices[devId]) {
                     devices[devId].publicIp = router.publicIp;
                     devices[devId].connectedRouterId = router.element.id;
                 }
            })
        });
        Object.keys(devices).forEach(updateDeviceIpDisplayInWorkspace);
        
        checkForConflicts();
        updateDdosState();
        updateAllDeviceScreens();
        updateCablePositions();
        updateAllVlanVisuals();
    };

    const updateAllDeviceScreens = () => {
        Object.keys(devices).forEach(id => {
            const device = devices[id];
            const screen = device.element.querySelector('.device-screen');
            if (!screen) return;
            
            // Priority: Conflict/DDoS visuals override everything
            if (device.element.classList.contains('ip-conflict')) {
                screen.className = "device-screen screen-ip-conflict-visuals";
                device.element.classList.add("has-connection");
                return;
            }
            if (device.element.classList.contains('under-ddos') || device.element.classList.contains('device-ddos-victim')) {
                device.element.classList.add('has-connection');
                // The DDoS classes already handle the screen content
                return;
            }
            
            // Clear previous state
            device.element.classList.remove('has-connection');
            screen.classList.remove('screen-internet', 'screen-lan-only', 'screen-internet-icon');

            // Check VPN or Anti-DDoS protection
            if (device.element.classList.contains('vpn-protected')) {
                device.element.classList.add('has-connection');
                screen.className = 'device-screen screen-internet';
                return;
            }
            if (device.element.classList.contains('ddos-protected')) {
                 device.element.classList.add('has-connection');
                 screen.classList.add('screen-internet-icon');
                 return;
            }

            // Regular connectivity check
            const hasInternet = !!device.publicIp;
            const isConnected = Object.values(cables).some(c => c.from === id || c.to === id);

            if (hasInternet) {
                device.element.classList.add('has-connection');
                if (device.type === 'router' || device.type === 'router-v2' || device.type === 'switch') {
                    screen.classList.add('screen-internet-icon');
                } else {
                    screen.classList.add('screen-internet');
                }
            } else if (isConnected) {
                device.element.classList.add('has-connection');
                screen.classList.add('screen-lan-only');
            }
        });
    };

    const exportState = () => {
        if (Object.keys(devices).length === 0) {
            addLog("Kh√¥ng c√≥ g√¨ ƒë·ªÉ xu·∫•t. H√£y th√™m thi·∫øt b·ªã.", "error");
            return;
        }
        const deviceData = Object.entries(devices).map(([id, dev]) => {
            const data = {
                id: id, name: dev.name, type: dev.type,
                ipEnabled: dev.ipEnabled, vpnEnabled: dev.vpnEnabled, vpnIp: dev.vpnIp,
                publicIp: (dev.type === "router" || dev.type === "router-v2") ? dev.publicIp : null, 
                privateIp: dev.privateIp,
                left: dev.element.style.left, top: dev.element.style.top
            };
            if (dev.type === 'router-v2') {
                data.vlans = dev.vlans;
                data.vlanAssignments = dev.vlanAssignments;
            }
            return data;
        });
        const cableData = Object.entries(cables).map(([id, cable]) => ({ id: id, from: cable.from, to: cable.to }));

        const state = { idCounter, deviceCounters, cableCounter, devices: deviceData, cables: cableData };
        
        const stateJson = JSON.stringify(state, null, 2);
        const blob = new Blob([stateJson], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'network-simulation.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        addLog("ƒê√£ xu·∫•t tr·∫°ng th√°i m·∫°ng ra file th√†nh c√¥ng!", "success");
    };

    const loadState = (state) => {
        clearWorkspace();
        try {
            idCounter = state.idCounter || 0; 
            cableCounter = state.cableCounter || 0;
            deviceCounters = state.deviceCounters || {};

            if (!state.deviceCounters && state.devices) {
                addLog("T·ªáp l∆∞u c≈© ƒë∆∞·ª£c ph√°t hi·ªán, ƒëang t·∫°o l·∫°i b·ªô ƒë·∫øm...", "warn");
                state.devices.forEach(device => {
                    if (!deviceCounters[device.type]) deviceCounters[device.type] = 0;
                    const match = device.name.match(/-(\d+)$/);
                    if (match) {
                        const num = parseInt(match[1], 10);
                        if (num > deviceCounters[device.type]) deviceCounters[device.type] = num;
                    }
                });
            }

            state.devices.forEach(devData => {
                const deviceElement = createDeviceElement(devData);
                workspace.appendChild(deviceElement);
                const devObject = {
                    element: deviceElement, name: devData.name, type: devData.type,
                    ipEnabled: devData.ipEnabled, vpnEnabled: devData.vpnEnabled, vpnIp: devData.vpnIp,
                    publicIp: devData.publicIp, privateIp: devData.privateIp, connectedRouterId: null
                };
                if (devData.type === 'router-v2') {
                    devObject.vlans = devData.vlans || [];
                    devObject.vlanAssignments = devData.vlanAssignments || {};
                }
                devices[devData.id] = devObject;
            });
            state.cables.forEach(cableData => {
                createCable(cableData.from, cableData.to, cableData.id);
            });
            updateAllDeviceStates();
            addLog("ƒê√£ t·∫£i tr·∫°ng th√°i m·∫°ng t·ª´ file th√†nh c√¥ng!", "success");
        } catch (error) {
            console.error("L·ªói khi t·∫£i tr·∫°ng th√°i:", error);
            addLog("File tr·∫°ng th√°i kh√¥ng h·ª£p l·ªá ho·∫∑c b·ªã l·ªói.", "error");
            clearWorkspace();
        }
    };
    
    const handleManualIpChange = (e) => {
        const deviceId = e.target.closest('.device').id;
        const device = devices[deviceId];
        if (!device) return;
        const newIp = e.target.value.trim();
        if (device.privateIp !== newIp) {
            addLog(`ƒê√£ c·∫≠p nh·∫≠t IP c·ªßa ${device.name} th√†nh ${newIp || 'ch∆∞a c√≥'}.`, 'info');
            device.privateIp = newIp || null;
            updateAllDeviceStates();
        }
    };

    const createCable = (fromId, toId, providedId = null) => {
        if (!devices[fromId] || !devices[toId]) return;
        if (Object.values(cables).some(c => (c.from === fromId && c.to === toId) || (c.from === toId && c.to === fromId))) {
            addLog(`K·∫øt n·ªëi gi·ªØa ${devices[fromId].name} v√† ${devices[toId].name} ƒë√£ t·ªìn t·∫°i!`, 'warn');
            return;
        }

        const cableId = providedId || `cable-${++cableCounter}`;
        if (!providedId) cableCounter++;

        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.id = cableId;
        line.setAttribute('stroke', 'var(--cable-color)');
        line.setAttribute('stroke-width', '4');
        line.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            showCableContextMenu(e.clientX, e.clientY, cableId);
        });
        cableSvg.appendChild(line);
        cables[cableId] = { id: cableId, from: fromId, to: toId, element: line };
        addLog(`ƒê√£ n·ªëi ${devices[fromId].name} v√† ${devices[toId].name}.`, 'success');
        updateAllDeviceStates();
    };

    const removeCable = (cableId, update = true) => {
        const cable = cables[cableId];
        if (cable) {
            const fromName = devices[cable.from]?.name || 'thi·∫øt b·ªã ƒë√£ x√≥a';
            const toName = devices[cable.to]?.name || 'thi·∫øt b·ªã ƒë√£ x√≥a';
            addLog(`ƒê√£ x√≥a k·∫øt n·ªëi gi·ªØa ${fromName} v√† ${toName}.`, 'warn');

            // Clean up VLAN assignment
            Object.values(devices).filter(d => d.type === 'router-v2').forEach(router => {
                if(router.vlanAssignments && router.vlanAssignments[cableId]) {
                    delete router.vlanAssignments[cableId];
                }
            });

            if (cable.element.parentNode) {
                cableSvg.removeChild(cable.element);
            }
            delete cables[cableId];
            if (update) {
                updateAllDeviceStates();
            }
        }
    };

    const updateCablePositions = () => {
        Object.values(cables).forEach(cable => {
            const fromEl = devices[cable.from]?.element;
            const toEl = devices[cable.to]?.element;
            if (fromEl && toEl) {
                const fromRect = fromEl.getBoundingClientRect();
                const toRect = toEl.getBoundingClientRect();
                const workspaceRect = workspace.getBoundingClientRect();
                const x1 = fromRect.left + fromRect.width / 2 - workspaceRect.left;
                const y1 = fromRect.top + fromRect.height / 2 - workspaceRect.top;
                const x2 = toRect.left + toRect.width / 2 - workspaceRect.left;
                const y2 = toRect.top + toRect.height / 2 - workspaceRect.top;
                cable.element.setAttribute('x1', x1);
                cable.element.setAttribute('y1', y1);
                cable.element.setAttribute('x2', x2);
                cable.element.setAttribute('y2', y2);
            }
        });
    };

    const updateDeviceIpDisplayInWorkspace = (deviceId) => {
        const device = devices[deviceId];
        if (!device || !device.ipEnabled) return;
        const publicIpEl = device.element.querySelector('.public-ip-on-device');
        if (!publicIpEl) return;

        if (device.vpnEnabled) {
            if (!device.vpnIp) {
                device.vpnIp = `45.8.${Math.floor(Math.random() * 254) + 1}.${Math.floor(Math.random() * 254) + 1}`;
            }
            publicIpEl.textContent = device.vpnIp;
            publicIpEl.style.color = 'var(--green-success)';
            publicIpEl.title = 'IP VPN (Ch·ªëng DDoS)';
        } else {
            publicIpEl.textContent = device.publicIp || 'Ch∆∞a k·∫øt n·ªëi';
            publicIpEl.style.color = 'var(--secondary-yellow)';
            publicIpEl.title = 'IP Public (t·ª´ Router)';
        }
    };

    const findReachableDevices = (startNodeId) => {
        const visited = new Set();
        const queue = [startNodeId];
        visited.add(startNodeId);
        while (queue.length > 0) {
            const currentId = queue.shift();
            Object.values(cables).forEach(cable => {
                let neighborId = null;
                if (cable.from === currentId) neighborId = cable.to;
                else if (cable.to === currentId) neighborId = cable.from;
                
                if (neighborId && !visited.has(neighborId)) {
                    visited.add(neighborId);
                    queue.push(neighborId);
                }
            });
        }
        return visited;
    };

    const findPath = (startId, endId) => {
        const queue = [{ id: startId, path: [startId], lastCableId: null }];
        const visited = new Set([startId]);

        while (queue.length > 0) {
            const { id: currentId, path, lastCableId } = queue.shift();

            if (currentId === endId) {
                return path;
            }

            Object.entries(cables).forEach(([cableId, cable]) => {
                let neighborId = null;
                if (cable.from === currentId) neighborId = cable.to;
                else if (cable.to === currentId) neighborId = cable.from;

                if (neighborId && !visited.has(neighborId)) {
                    const currentNode = devices[currentId];
                    // VLAN Check at Router V2
                    if (currentNode?.type === 'router-v2') {
                        const vlanIn = currentNode.vlanAssignments[lastCableId];
                        const vlanOut = currentNode.vlanAssignments[cableId];
                        if (vlanIn !== vlanOut) {
                            return; // Block path if VLANs don't match
                        }
                    }
                    visited.add(neighborId);
                    queue.push({ id: neighborId, path: [...path, neighborId], lastCableId: cableId });
                }
            });
        }
        return null; // No path found
    };

    const checkForConflicts = () => {
        const ipMap = {};
        Object.values(devices).forEach(dev => {
            dev.element.classList.remove('ip-conflict');
        });

        Object.entries(devices).forEach(([id, device]) => {
            if (device.privateIp) {
                if (!ipMap[device.privateIp]) {
                    ipMap[device.privateIp] = [];
                }
                ipMap[device.privateIp].push(id);
            }
        });

        Object.values(ipMap).forEach(ids => {
            if (ids.length > 1) {
                const conflictIp = devices[ids[0]].privateIp;
                addLog(`Ph√°t hi·ªán tr√πng IP: ${conflictIp}`, 'error');
                ids.forEach(id => {
                    const device = devices[id];
                    if (device) {
                        device.element.classList.add('ip-conflict');
                    }
                });
            }
        });
    };

    const runDhcp = () => {
        addLog("B·∫Øt ƒë·∫ßu ti·∫øn tr√¨nh c·∫•p IP (DHCP)...", "warn");
        const routers = Object.entries(devices).filter(([, dev]) => dev.type === 'router' || dev.type === 'router-v2');
        let regularRouterCounter = 0;

        routers.forEach(([routerId, router]) => {
            if (router.type === 'router') {
                regularRouterCounter++;
                let subnet = `192.168.${regularRouterCounter}.`;
                let lastOctet = 10;
                
                const connectedDevices = findReachableDevices(routerId);
                connectedDevices.forEach(devId => {
                    const device = devices[devId];
                    if (device && device.ipEnabled && !device.privateIp) {
                         let newIp;
                         do {
                             newIp = subnet + lastOctet++;
                         } while (Object.values(devices).some(d => d.privateIp === newIp));
                         device.privateIp = newIp;
                         const ipInput = device.element.querySelector('.ip-input');
                         if (ipInput) ipInput.value = device.privateIp;
                         addLog(`ƒê√£ c·∫•p IP ${device.privateIp} cho ${device.name}`, 'success');
                    }
                });
            } else if (router.type === 'router-v2') {
                // DHCP for each configured VLAN
                router.vlans.forEach(vlan => {
                    let subnet = `192.168.${vlan.id}.`;
                    let lastOctet = 10;
                    const devicesInVlan = Object.entries(cables)
                        .filter(([, c]) => (c.from === routerId || c.to === routerId) && router.vlanAssignments[c.id] === vlan.id)
                        .map(([, c]) => devices[c.from === routerId ? c.to : c.from]);
                    
                    devicesInVlan.forEach(device => {
                        if (device && device.ipEnabled && !device.privateIp) {
                             let newIp;
                             do {
                                 newIp = subnet + lastOctet++;
                             } while (Object.values(devices).some(d => d.privateIp === newIp));
                             device.privateIp = newIp;
                             const ipInput = device.element.querySelector('.ip-input');
                             if (ipInput) ipInput.value = device.privateIp;
                             addLog(`ƒê√£ c·∫•p IP ${device.privateIp} cho ${device.name} (VLAN ${vlan.id})`, 'success');
                        }
                    });
                });

                // DHCP for untagged devices
                let untaggedSubnet = `192.168.254.`;
                let untaggedLastOctet = 10;
                const untaggedDevices = Object.entries(cables)
                    .filter(([, c]) => (c.from === routerId || c.to === routerId) && !router.vlanAssignments[c.id])
                    .map(([, c]) => devices[c.from === routerId ? c.to : c.from]);

                untaggedDevices.forEach(device => {
                     if (device && device.ipEnabled && !device.privateIp) {
                         let newIp;
                         do {
                             newIp = untaggedSubnet + untaggedLastOctet++;
                         } while (Object.values(devices).some(d => d.privateIp === newIp));
                         device.privateIp = newIp;
                         const ipInput = device.element.querySelector('.ip-input');
                         if (ipInput) ipInput.value = device.privateIp;
                         addLog(`ƒê√£ c·∫•p IP ${device.privateIp} cho ${device.name} (VLAN M·∫∑c ƒë·ªãnh)`, 'success');
                    }
                });
            }
        });
        updateAllDeviceStates();
        addLog("Ho√†n t·∫•t c·∫•p IP.", "success");
    };

    // --- Event Handlers ---
    function onDeviceDoubleClick(e) {
        const deviceId = e.currentTarget.id;
        const device = devices[deviceId];
        if (device.type === 'pc' || device.type === 'phone') {
            showDeviceInfoModal(deviceId);
        } else if (device.type === 'router-v2') {
            showVlanModal(deviceId);
        }
    }

    function onDeviceClick(e) {
        if (pingInProgress || e.target.closest('.ip-input, .connect-btn')) return;
        const deviceId = e.currentTarget.id;
        if (isPingMode && pingSourceDevice && pingSourceDevice !== deviceId) {
            executePing(pingSourceDevice, deviceId);
        }
    }

    function onMouseDown(e) {
        if (isConnecting || pingInProgress || e.target.closest('.ip-input, .remove-btn, .ping-btn, .connect-btn')) return;
        draggedDevice = e.currentTarget;
        draggedDevice.style.cursor = 'grabbing';
        draggedDevice.style.zIndex = 1000;
        const rect = draggedDevice.getBoundingClientRect();
        offsetX = e.clientX - rect.left;
        offsetY = e.clientY - rect.top;
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
    }

    function onConnectStart(e) {
        e.stopPropagation();
        isConnecting = true;
        connectionSourceId = e.target.closest('.device').id;
        const sourceEl = devices[connectionSourceId].element;
        const workspaceRect = workspace.getBoundingClientRect();
        const sourceRect = sourceEl.getBoundingClientRect();
        const startX = sourceRect.left + sourceRect.width / 2 - workspaceRect.left;
        const startY = sourceRect.top + sourceRect.height / 2 - workspaceRect.top;
        tempCableLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        tempCableLine.setAttribute('stroke', 'var(--secondary-yellow)');
        tempCableLine.setAttribute('stroke-width', '4');
        tempCableLine.setAttribute('stroke-dasharray', '5 5');
        tempCableLine.setAttribute('x1', startX);
        tempCableLine.setAttribute('y1', startY);
        tempCableLine.setAttribute('x2', startX);
        tempCableLine.setAttribute('y2', startY);
        cableSvg.appendChild(tempCableLine);
        document.addEventListener('mousemove', onConnectMove);
        document.addEventListener('mouseup', onConnectEnd, { once: true });
    }

    function onConnectMove(e) {
        if (!isConnecting || !tempCableLine) return;
        const workspaceRect = workspace.getBoundingClientRect();
        const endX = e.clientX - workspaceRect.left;
        const endY = e.clientY - workspaceRect.top;
        tempCableLine.setAttribute('x2', endX);
        tempCableLine.setAttribute('y2', endY);
    }

    function onConnectEnd(e) {
        if (tempCableLine) {
            tempCableLine.remove();
            tempCableLine = null;
        }
        const targetEl = document.elementFromPoint(e.clientX, e.clientY)?.closest('.device');
        if (targetEl && devices[targetEl.id] && targetEl.id !== connectionSourceId) {
            createCable(connectionSourceId, targetEl.id);
        }
        isConnecting = false;
        connectionSourceId = null;
        document.removeEventListener('mousemove', onConnectMove);
    }

    function onMouseMove(e) {
        if (!draggedDevice) return;
        const workspaceRect = workspace.getBoundingClientRect();
        let newLeft = e.clientX - offsetX - workspaceRect.left;
        let newTop = e.clientY - offsetY - workspaceRect.top;
        newLeft = Math.max(0, Math.min(newLeft, workspace.clientWidth - draggedDevice.offsetWidth));
        newTop = Math.max(0, Math.min(newTop, workspace.clientHeight - draggedDevice.offsetHeight));
        draggedDevice.style.left = `${newLeft}px`;
        draggedDevice.style.top = `${newTop}px`;
        updateCablePositions();
    }

    function onMouseUp() {
        if (draggedDevice) {
            draggedDevice.style.cursor = 'grab';
            draggedDevice.style.zIndex = 'auto';
        }
        draggedDevice = null;
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
    }

    const startPing = (deviceId) => {
        if (isConnecting || pingInProgress) {
            addLog('Kh√¥ng th·ªÉ Ping khi ƒëang th·ª±c hi·ªán h√†nh ƒë·ªông kh√°c.', 'error');
            return;
        }
        isPingMode = true;
        pingSourceDevice = deviceId;
        Object.values(devices).forEach(d => d.element.classList.remove('ping-source'));
        devices[deviceId].element.classList.add('ping-source');
        workspace.style.cursor = 'crosshair';
        addLog(`Ch·∫ø ƒë·ªô Ping: T·ª´ ${devices[deviceId].name}. Ch·ªçn thi·∫øt b·ªã ƒë√≠ch.`, 'warn');
    };

    const cancelPingSelection = () => {
        isPingMode = false;
        if (pingSourceDevice && devices[pingSourceDevice]) {
            devices[pingSourceDevice].element.classList.remove('ping-source');
        }
        pingSourceDevice = null;
        workspace.style.cursor = 'default';
        addLog('ƒê√£ h·ªßy ch·∫ø ƒë·ªô ch·ªçn Ping.', 'info');
    };

    const endPingProcess = () => {
        if (!pingInProgress) return;
        if (pingTimeoutId) clearTimeout(pingTimeoutId);
        pingTimeoutId = null;
        pingInProgress = false;
        workspace.classList.remove('ping-isolation-mode');
        cableSvg.classList.remove('ping-isolation-mode');
        document.querySelectorAll('.ping-active').forEach(el => el.classList.remove('ping-active'));
        pingOverlay.style.display = 'none';
        pingLogDisplay.innerHTML = '';
        addLog('Ti·∫øn tr√¨nh Ping ƒë√£ k·∫øt th√∫c.', 'info');
    };

    const animatePingPackets = (path, durationPerHop = 1000) => {
        for (let i = 0; i < path.length - 1; i++) {
            const fromId = path[i];
            const toId = path[i+1];
            const cable = Object.values(cables).find(c => (c.from === fromId && c.to === toId) || (c.from === toId && c.to === fromId));
            if (cable) {
                setTimeout(() => {
                    if (!pingInProgress) return;
                    const pingLine = cable.element.cloneNode();
                    pingLine.removeAttribute('id');
                    pingLine.classList.add('cable-ping');
                    pingLine.style.animationDuration = `${durationPerHop / 1000}s`;
                    cableSvg.appendChild(pingLine);
                    pingLine.addEventListener('animationend', () => {
                        if (pingLine.parentNode === cableSvg) cableSvg.removeChild(pingLine);
                    });

                    const x1 = cable.element.getAttribute('x1');
                    const y1 = cable.element.getAttribute('y1');
                    const x2 = cable.element.getAttribute('x2');
                    const y2 = cable.element.getAttribute('y2');
                    const textEl = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    textEl.textContent = 'ping';
                    textEl.classList.add('ping-packet-text');

                    const motion = document.createElementNS('http://www.w3.org/2000/svg', 'animateMotion');
                    motion.setAttribute('dur', `${durationPerHop/1000}s`);
                    motion.setAttribute('fill', 'freeze');
                    motion.setAttribute('path', `M${x1},${y1} L${x2},${y2}`);
                    textEl.appendChild(motion);
                    cableSvg.appendChild(textEl);
                    setTimeout(() => {
                        if (textEl.parentNode === cableSvg) cableSvg.removeChild(textEl);
                    }, durationPerHop);

                }, i * durationPerHop);
            }
        }
    };
    
    const executePing = (sourceId, targetId) => {
        const sourceDevice = devices[sourceId];
        const targetDevice = devices[targetId];
        const targetName = targetDevice.privateIp || targetDevice.name;
        cancelPingSelection();
        addLog(`B·∫Øt ƒë·∫ßu ping t·ª´ ${sourceDevice.name} ƒë·∫øn ${targetDevice.name}...`, 'info');
        
        const path = findPath(sourceId, targetId);
        pingInProgress = true;
        workspace.classList.add('ping-isolation-mode');
        cableSvg.classList.add('ping-isolation-mode');
        pingOverlay.style.display = 'flex';
        pingLogDisplay.innerHTML = '';
        
        const logPing = (message, color = 'white') => {
            const p = document.createElement('p');
            p.textContent = message;
            p.style.color = color;
            pingLogDisplay.appendChild(p);
            pingLogDisplay.scrollTop = pingLogDisplay.scrollHeight;
        };

        if (path) {
            path.forEach(id => devices[id].element.classList.add('ping-active'));
            for (let i = 0; i < path.length - 1; i++) {
                const cable = Object.values(cables).find(c => (c.from === path[i] && c.to === path[i+1]) || (c.from === path[i+1] && c.to === path[i]));
                if (cable) cable.element.classList.add('ping-active');
            }
            logPing(`Pinging ${targetDevice.name} [${targetName}] with 32 bytes of data:`);
            let count = 0;
            const interval = 1500;
            const sendReply = () => {
                if (!pingInProgress) return;
                if (count >= 4) {
                    logPing(`\nPing statistics for ${targetName}:`);
                    logPing(`    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss)`, 'var(--secondary-yellow)');
                    pingTimeoutId = setTimeout(endPingProcess, 2000);
                    return;
                }
                const latency = (path.length - 1) * 2 + Math.floor(Math.random() * 10);
                logPing(`Reply from ${targetName}: bytes=32 time=${latency}ms TTL=128`, 'var(--green-success)');
                animatePingPackets(path, 1000);
                count++;
                pingTimeoutId = setTimeout(sendReply, interval);
            };
            sendReply();
        } else {
            sourceDevice.element.classList.add('ping-active');
            targetDevice.element.classList.add('ping-active');
            logPing(`Pinging ${targetDevice.name} [${targetName}]...`);
            logPing('Request timed out.', 'var(--red-error)');
            pingTimeoutId = setTimeout(() => {
                if(!pingInProgress) return;
                logPing('Request timed out.', 'var(--red-error)');
                logPing(`\nPing statistics for ${targetName}:`);
                logPing(`    Packets: Sent = 2, Received = 0, Lost = 2 (100% loss)`, 'var(--secondary-yellow)');
                pingTimeoutId = setTimeout(endPingProcess, 3000);
            }, 1500);
        }
    };
    
    // --- Modal Functions ---
    const showConnectionModal = (newDeviceId, newDeviceName) => {
        modalTitle.textContent = `K·∫øt n·ªëi ${newDeviceName} v·ªõi c√°c thi·∫øt b·ªã`;
        connectionModal.dataset.newDeviceId = newDeviceId;
        deviceFilterButtons.querySelector('button.active')?.classList.remove('active');
        deviceFilterButtons.querySelector('button[data-filter="all"]').classList.add('active');
        populateDeviceList('all');
        connectionModal.style.display = 'flex';
    };
    const hideConnectionModal = () => { connectionModal.style.display = 'none'; };

    const isAlreadyConnectedToSwitchOrRouter = (deviceId) => {
         return Object.values(cables).some(c => {
            let neighborId = null;
            if (c.from === deviceId) neighborId = c.to;
            else if (c.to === deviceId) neighborId = c.from;
            else return false;
            
            return neighborId && devices[neighborId] && ['switch', 'router', 'router-v2'].includes(devices[neighborId].type);
        });
    };

    const populateDeviceList = (filter) => {
        deviceSelectionList.innerHTML = '';
        const availableDevices = Object.entries(devices)
            .filter(([id, dev]) => (dev.type === 'pc' || dev.type === 'phone') && !isAlreadyConnectedToSwitchOrRouter(id))
            .filter(([, dev]) => filter === 'all' || dev.type === filter);
        
        if (availableDevices.length === 0) {
            deviceSelectionList.innerHTML = '<p style="text-align:center; width:100%; padding: 20px 0;">Kh√¥ng c√≥ thi·∫øt b·ªã n√†o ph√π h·ª£p.</p>';
            return;
        }

        availableDevices.forEach(([id, dev]) => {
            const item = document.createElement('div');
            item.className = 'device-list-item';
            item.textContent = `${dev.name} ${dev.type === 'pc' ? 'üíª' : 'üì±'}`;
            item.dataset.deviceId = id;
            item.addEventListener('click', () => item.classList.toggle('selected'));
            deviceSelectionList.appendChild(item);
        });
    };

    const showDeviceInfoModal = (deviceId) => {
        const device = devices[deviceId];
        if (device) {
            deviceInfoModal.dataset.currentDeviceId = deviceId;
            infoModalTitle.textContent = `Th√¥ng tin ${device.name}`;
            infoDeviceName.textContent = device.name;
            infoPrivateIp.textContent = device.privateIp || 'Ch∆∞a ƒë∆∞·ª£c c·∫•p';
            vpnToggle.checked = device.vpnEnabled;
            updateVpnDisplay(deviceId);
            deviceInfoModal.style.display = 'flex';
        }
    };
    const hideDeviceInfoModal = () => { deviceInfoModal.style.display = 'none'; };

    const updateVpnDisplay = (deviceId) => {
        const device = devices[deviceId];
        if (!device) return;
        const vpnLabel = deviceInfoModal.querySelector('.vpn-info-label');
        const vpnIpDisplay = deviceInfoModal.querySelector('#info-vpn-ip');

        infoPublicIp.textContent = device.publicIp || 'Kh√¥ng c√≥ Internet';
        infoPublicIp.style.color = device.publicIp ? 'var(--secondary-yellow)' : 'var(--red-error)';

        if (device.vpnEnabled) {
            if(!device.vpnIp) device.vpnIp = `45.8.${Math.floor(Math.random() * 254) + 1}.${Math.floor(Math.random() * 254) + 1}`;
            vpnIpDisplay.textContent = device.vpnIp;
            vpnIpDisplay.style.color = 'var(--green-success)';
            vpnLabel.style.display = '';
            vpnIpDisplay.style.display = '';
            vpnStatus.textContent = 'ƒêang B·∫¨T';
        } else {
            vpnLabel.style.display = 'none';
            vpnIpDisplay.style.display = 'none';
            vpnStatus.textContent = 'ƒêang T·∫ÆT';
        }
    };

    const showCableContextMenu = (x, y, cableId) => {
        removeCableContextMenu();
        const menu = document.createElement('div');
        menu.id = 'cable-context-menu';
        menu.style.left = `${x}px`;
        menu.style.top = `${y}px`;
        menu.innerHTML = `<button>X√≥a k·∫øt n·ªëi</button>`;
        document.body.appendChild(menu);
        menu.querySelector('button').addEventListener('click', () => {
            removeCable(cableId);
            removeCableContextMenu();
        });
    };
    const removeCableContextMenu = () => { document.getElementById('cable-context-menu')?.remove(); };

    const showVlanModal = (routerId) => {
        const router = devices[routerId];
        if (!router || router.type !== 'router-v2') return;

        vlanModal.dataset.currentRouterId = routerId;
        vlanModalTitle.textContent = `Qu·∫£n l√Ω VLAN cho ${router.name}`;
        vlanModal.dataset.tempVlans = JSON.stringify(router.vlans);
        populateVlanPortAssignments(routerId);
        vlanModal.style.display = 'flex';
    };
    const hideVlanModal = () => {
        vlanModal.style.display = 'none';
        vlanIdInput.value = '';
        vlanNameInput.value = '';
    };

    const populateVlanPortAssignments = (routerId) => {
        const router = devices[routerId];
        const tempVlans = JSON.parse(vlanModal.dataset.tempVlans);
        vlanPortAssignments.innerHTML = '';

        const connectedCables = Object.values(cables).filter(c => c.from === routerId || c.to === routerId);

        if (connectedCables.length === 0) {
            vlanPortAssignments.innerHTML = '<p style="text-align: center; padding: 10px 0;">Kh√¥ng c√≥ thi·∫øt b·ªã n√†o ƒë∆∞·ª£c k·∫øt n·ªëi.</p>';
            return;
        }

        connectedCables.forEach(cable => {
            const neighborId = cable.from === routerId ? cable.to : cable.from;
            const neighborDevice = devices[neighborId];
            if (!neighborDevice) return;

            const item = document.createElement('div');
            item.className = 'vlan-port-item';
            item.dataset.cableId = cable.id;

            const nameSpan = document.createElement('span');
            nameSpan.textContent = `C·ªïng t·ªõi ${neighborDevice.name}`;

            const select = document.createElement('select');
            select.innerHTML = '<option value="">M·∫∑c ƒë·ªãnh (Untagged)</option>';
            tempVlans.forEach(vlan => {
                const option = document.createElement('option');
                option.value = vlan.id;
                option.textContent = `VLAN ${vlan.id}: ${vlan.name}`;
                option.style.color = `var(${vlanColors[vlan.id % vlanColors.length]})`;
                select.appendChild(option);
            });

            const currentVlanId = router.vlanAssignments[cable.id];
            if (currentVlanId) {
                select.value = currentVlanId;
            }

            item.appendChild(nameSpan);
            item.appendChild(select);
            vlanPortAssignments.appendChild(item);
        });
    };

    const updateAllVlanVisuals = () => {
        Object.values(cables).forEach(cable => {
            cable.element.style.stroke = ''; // Reset to default color via CSS
        });

        Object.values(devices).filter(d => d.type === 'router-v2').forEach(router => {
            Object.entries(router.vlanAssignments).forEach(([cableId, vlanId]) => {
                const cable = cables[cableId];
                if (cable && cable.element) {
                    const colorVar = vlanColors[vlanId % vlanColors.length];
                    cable.element.style.stroke = `var(${colorVar})`;
                }
            });
        });
    };

    // --- Event Listeners Setup ---
    addSelectedDeviceBtn.addEventListener('click', () => {
        const selectedType = addDeviceSelect.value;
        const typeMap = {
            'pc': { name: 'PC', ip: true },
            'phone': { name: 'Phone', ip: true },
            'router': { name: 'Router', ip: false },
            'router-v2': { name: 'RouterV2', ip: false },
            'switch': { name: 'Switch', ip: false },
            'firewall': { name: 'Firewall', ip: false },
            'anti-ddos-system': { name: 'Anti-DDoS', ip: false },
        };
        if(typeMap[selectedType]) {
            addDevice(selectedType, typeMap[selectedType].name, typeMap[selectedType].ip);
        }
    });

    addDdosBtn.addEventListener('click', () => addDevice('ddos', 'DDoS Server', false));
    autoIpBtn.addEventListener('click', runDhcp);

    addMultiPcBtn.addEventListener('click', () => {
        const count = parseInt(multiPcCountInput.value, 10);
        if (isNaN(count) || count <= 0) {
            addLog("Vui l√≤ng nh·∫≠p s·ªë l∆∞·ª£ng h·ª£p l·ªá.", "error");
            return;
        }
        addLog(`ƒêang t·∫°o ${count} PC...`, "warn");
        for (let i = 0; i < count; i++) addDevice('pc', 'PC');
        addLog(`ƒê√£ t·∫°o xong ${count} PC.`, "success");
    });
    
    exportBtn.addEventListener('click', exportState);
    importBtn.addEventListener('click', () => importFileInput.click());
    importFileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const state = JSON.parse(event.target.result);
                loadState(state);
            } catch (error) {
                addLog("L·ªói: Kh√¥ng th·ªÉ ƒë·ªçc file JSON.", "error");
            }
        };
        reader.readAsText(file);
        e.target.value = null; // Reset for next import
    });
    
    cancelPingBtn.addEventListener('click', endPingProcess);
    cancelConnectBtn.addEventListener('click', hideConnectionModal);
    infoModalCloseBtn.addEventListener('click', hideDeviceInfoModal);
    helpBtn.addEventListener('click', () => { helpModal.style.display = 'flex'; });
    helpModalCloseBtn.addEventListener('click', () => { helpModal.style.display = 'none'; });
    helpModal.addEventListener('click', (e) => { if (e.target === helpModal) helpModal.style.display = 'none'; });
    
    vpnToggle.addEventListener('change', (e) => {
        const deviceId = deviceInfoModal.dataset.currentDeviceId;
        if (!deviceId || !devices[deviceId]) return;
        devices[deviceId].vpnEnabled = e.target.checked;
        addLog(`VPN Ch·ªëng DDoS tr√™n ${devices[deviceId].name} ƒë√£ ƒë∆∞·ª£c ${e.target.checked ? "B·∫¨T" : "T·∫ÆT"}.`, 'warn');
        updateVpnDisplay(deviceId);
        updateDeviceIpDisplayInWorkspace(deviceId);
        updateAllDeviceStates(); 
    });

    connectSelectedBtn.addEventListener('click', () => {
        const newDeviceId = connectionModal.dataset.newDeviceId;
        if (!newDeviceId) return;
        const selectedItems = deviceSelectionList.querySelectorAll('.device-list-item.selected');
        addLog(`ƒêang k·∫øt n·ªëi ${devices[newDeviceId].name} v·ªõi ${selectedItems.length} thi·∫øt b·ªã...`, 'info');
        selectedItems.forEach(item => createCable(newDeviceId, item.dataset.deviceId));
        hideConnectionModal();
    });

    connectAllBtn.addEventListener('click', () => {
        const newDeviceId = connectionModal.dataset.newDeviceId;
        if (!newDeviceId) return;
        const allItems = deviceSelectionList.querySelectorAll('.device-list-item');
        addLog(`ƒêang k·∫øt n·ªëi ${devices[newDeviceId].name} v·ªõi t·∫•t c·∫£ ${allItems.length} thi·∫øt b·ªã...`, 'info');
        allItems.forEach(item => createCable(newDeviceId, item.dataset.deviceId));
        hideConnectionModal();
    });

    deviceFilterButtons.addEventListener('click', (e) => {
        if(e.target.tagName === 'BUTTON') {
            deviceFilterButtons.querySelector('button.active')?.classList.remove('active');
            e.target.classList.add('active');
            populateDeviceList(e.target.dataset.filter);
        }
    });

    addVlanBtn.addEventListener('click', () => {
        const routerId = vlanModal.dataset.currentRouterId;
        const tempVlans = JSON.parse(vlanModal.dataset.tempVlans);
        const vlanId = parseInt(vlanIdInput.value, 10);
        const vlanName = vlanNameInput.value.trim();

        if (!vlanId || vlanId < 1 || vlanId > 4094) { addLog("VLAN ID ph·∫£i l√† m·ªôt s·ªë t·ª´ 1 ƒë·∫øn 4094.", "error"); return; }
        if (!vlanName) { addLog("Vui l√≤ng nh·∫≠p t√™n cho VLAN.", "error"); return; }
        if (tempVlans.some(v => v.id === vlanId)) { addLog(`VLAN ID ${vlanId} ƒë√£ t·ªìn t·∫°i.`, "error"); return; }

        tempVlans.push({ id: vlanId, name: vlanName });
        vlanModal.dataset.tempVlans = JSON.stringify(tempVlans);
        addLog(`ƒê√£ th√™m t·∫°m th·ªùi VLAN ${vlanId} (${vlanName}). Nh·∫•n L∆∞u ƒë·ªÉ √°p d·ª•ng.`, "info");
        populateVlanPortAssignments(routerId);
        vlanIdInput.value = '';
        vlanNameInput.value = '';
    });
    
    saveVlanConfigBtn.addEventListener('click', () => {
        const routerId = vlanModal.dataset.currentRouterId;
        const router = devices[routerId];
        if (!router) return;

        router.vlans = JSON.parse(vlanModal.dataset.tempVlans);
        const newAssignments = {};
        vlanPortAssignments.querySelectorAll('.vlan-port-item').forEach(item => {
            const cableId = item.dataset.cableId;
            const select = item.querySelector('select');
            const vlanId = select.value ? parseInt(select.value, 10) : null;
            if (vlanId) newAssignments[cableId] = vlanId;
        });
        router.vlanAssignments = newAssignments;
        addLog(`ƒê√£ l∆∞u c·∫•u h√¨nh VLAN cho ${router.name}.`, "success");
        hideVlanModal();
        updateAllDeviceStates();
    });

    cancelVlanConfigBtn.addEventListener('click', hideVlanModal);
    
    document.addEventListener('click', (e) => {
        if (!e.target.closest('#cable-context-menu') && !e.target.closest('#cable-svg line')) {
            removeCableContextMenu();
        }
    });

    document.addEventListener('keydown', e => {
        if (e.key === 'Escape') {
            if (helpModal.style.display === 'flex') { helpModal.style.display = 'none'; return; }
            if (vlanModal.style.display === 'flex') { hideVlanModal(); return; }
            if (pingInProgress) { endPingProcess(); return; }
            if (isPingMode) { cancelPingSelection(); return; }
            hideConnectionModal();
            hideDeviceInfoModal();
            removeCableContextMenu();
        }
    });

    new ResizeObserver(updateCablePositions).observe(workspace);
    addLog("Ch√†o m·ª´ng! H·ªá th·ªëng ƒë√£ s·∫µn s√†ng. Nh·∫•n '?' ƒë·ªÉ xem h∆∞·ªõng d·∫´n.", "success");
});
</script>

</body>
</html>
